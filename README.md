# nxn-boot
framework for large scale applications, supporting configuration file, services, routes, express middleware, client data.

This npm module addresses requirements of medium to large applications.

Included in this framework:

*Modular development* : 
- applications are organised with : services, routes, test, models, scripts, nodes that are written as js classes.
- code can be generated using "nxg" (ex. nxg service myapp/mysce generates a class /applications/myapp/services/mysce.service.js). nxg is a npm cli (@nxn/cli)
- each service/route/test/script can use configuration parameters that are managed by the framework (thanks to @nxn/config package). Configuration is written in json or yaml.
- the framework supports "nodes" that are services with a "message" interface similar to Node red nodes and injections. A node implement a functionnality (ex. read Google buckets, mongodb collections, files, etc.) and are linked to other nodes (ex. parser, writer to another DB, etc.) with injections. A Node : "process" received message, do something and send message(s) to connected nodes.

*Application = Configuration* :
application are organised as:
- code of the application : organised as services, nodes, tests, etc.
- a "boot" configuration that executes the application modules.
we can then define one or several configurations that use applications module, and thus implement several versions of applications with the same code base. An exemple is to run a local application with mongodb for testing, and the same application running firestore when deployed on GCP. Because of the modular design, the application doesnt need to know which db it runs with..

*Multi tenant and multi applications* :
- it is possible to have one or several "clients" on the same project. nxn boot supports a "client data" directory where all information/data related to a client is stored.
- an application is actually a configuration and can be deployed to several clients.

*Management of express middleware* :
- main index.js file doesn't need to be modified. It is generated by the nxg CLI and is the same for all applications. Nxn boot use middleware that is requested in the configuration file (ex. cors, json, etc.). Middleware are also written (ideally) as classes.
- express can be used along with nxn boot if the application implements an API. But an application can also be written as a programm that execute tasks at specified times (using "cron" service that executes "tasks").

*This framework is inspired by* :
- Angular : injections, services, components and cli
- APIGEE : management of middleware,
- node red : implementation of flow based applications, granular configurations of each node and service,
- PHP propriatery framework from PresenceSoft : multi tenant architectures (client data) and "applications as configuration",
- low code frameworks : granular and independant tasks for creating a functionality.
- OAS / Swagger : configuration oriented spec and $ref() in YAML

The framework is best used with other modules from @nxn:
- files : service providing async access to files,
- cli : generating code,
- config : for reading configuration files in YAML, json or env formats,
- google : a set of services and nodes for accessing google APIs in a "configrable" way (bucket reader/writer, firestore, auth, etc.)
- ext : tools extending arrays, objects and strings,
- db : mongodb and mysql.

*How to use it* :
Install boot:
    npm install @nxn/boot

Install cli globally :
npm install @nxn/cli -g

Use cli to generate application and default config & client data:
    nxg client default

run application:
    node index.js default config 
or
    node index.js 

*Words of caution*
nb. the cli tool is very convenient for generating services and nodes. It needs to be improved so that we can generate the main app, configuration, etc. and alos update the config files automatically when a node or service is added. This will come soon, although the focus now is on the nodes themselves and further integration with Google products and other APIs. In its current version, it is similar to Angular CLI tool for generating components : it generates code. But like Angular CLI, it idoesn't yet declare the components in the list of modules/nodes config. So still a bit manual. The goal it to complete it so that it goes the extra mile and declare the node/service in the application config. Just like node-red does when a node is added to the config....

The latest version of @nxn/config is very promising as it provides lots of flexibility in writing configuration with variables, environements and inclusion of other files.. We'll come back to that point later as this opens paths to other ideas...

# SAMPLE CREATION OF A PROJECT

## create project folder

```shell
    mkdir ./project1

    cd project1
```

## install nxn boot and cli

```shell
    npm install @nxn/boot

    npm install @nxn/cli
```

NB. nxg is then available for generating project structure

## create project structure

```shell
    nxg client default
```

- this creates a basic project structure

- install dependencies 

```shell
npm install
```

- try basic project

```shell
    node index.js default config
```

## create a service

create service "/applications/module1/services/sce1.service.js" in application module "module1"

```shell
    nxg service module1 sce1
```

generates a new file.

add it in configuration:

```yaml

services:
    configuration:
        ...
        sce1:
            upath: sce1@module1
```

## create a test for that same service

creates a class "/applications/module1/tests/sce1.test.js" in application module "module1"

```shell
    nxg test module1 sce1
```

add it in configuration:

```yaml

tests:
    configuration:
        ...
        sce1:
            upath: sce1@module1
```

## create a route for that same service

creates a class "/applications/module1/routes/api1.route.js" in application module "module1"

```shell
    nxg route module1 api1
```

add it in configuration:

```yaml

routes:
    configuration:
        ...
        api1:
            url: /api1
            upath: api1@module1
```


## 03/02/2024 added components in config

it is now possible to create a sub config file with services, routes etc.

can then be loaded in "components" section
ex.
```yaml

components:
  load: all

  configuration:
    # components : include services, routes, tests
    glabels: $ref(/applications/googleapi/config/glabel.component) # labels
    gbuckets: $ref(/applications/googleapi/config/gbuckets.component) # buckets

```

with : /applications/googleapi/config/glabel.component.yml 

```yaml

# google labels component : service and test suite

services:
  glabels:
    upath: glabels@googleapi
    labels:
      confidentiality:
        #match: "DLP"
        enums: 
          confidential: "(confidential|secret)"
          internal: "(intern[ae])"
          public: "Public"
tests:
  glabel_test:
    upath: glabels@googleapi
    token: ${{TEST_TOKEN||""}}
    injections:
      glabels: glabels
```
and:

/applications/googleapi/config/gbuckets.component.yml

```yaml
  
  # filestore buckets component : service and test suite

services:
  # filestore buckets service
  gbuckets:
    upath: gbuckets@googleapi
    conPath: .filestore
    bucket_name: "pdoc_file_revisions_${GED_CLIENT_ID}"
    secret_id: "gbuckets-${SECRET_SUFFIX_FIRESTORE}" # ex. gbuckets-env
    injections:
        secrets: googleSecretsYAML

tests:
  gbuckets_tests:
    upath: gbuckets@googleapi
    token: ${{TEST_TOKEN||""}}
    injections:
      gbuckets: gbuckets # use service account for storage
```

module configs are simply added to main config by sections.

## Test suite

Here is an example of a test.

A test is basically like a service. It gets ijected resources to test, and
runs at startup. It uses "assert" to check if everything runs as expected.

```js
var assert = require('assert');
const {bootSce} = require("@nxn/boot");

const FlowNode = require("@nxn/boot/node");
const debug = require("@nxn/debug")('TEST GGROUPS');

class Tests extends FlowNode
{
    constructor() {
        super();
    }

    init(config,ctxt,...injections)
    {
        super.init(config,ctxt,injections);

        /** @type {import('../services/gbuckets.service').GBucketInstance} */
        this.gbuckets = 
            this.getInjection('gbuckets'); // get injection
        
        if(!(config.active === false))
            this.run();
    }

    async run() 
    {
        try 
        {
            // await for services init to finish
            await new Promise(resolve => setTimeout(resolve, 5000));
            
            // init tests data
            let gbuckets = this.gbuckets;

            /** @type {import('../types/types').gUser} */
            let user = {email:"franck@presencemedia.ma", gToken:null};

            // search for groups starting with dev
            debug.log("test 0 : list files in buckets");   
            try 
            {
                assert.ok(gbuckets,"Bucket injection not valid");
                assert.ok(gbuckets,"Bucket name not set");
                debug.log("Bucket OK : name : "+gbuckets.bucketName);

                const files = await gbuckets.listFiles();
                console.log("Files",files);

                const filename = "TEST.txt";

                debug.log("Add file "+filename);
                let file = await gbuckets.writeFileData(filename,"simple test",{version:"1", revision:"1"});
                assert.ok(file,"file couldnt be added to bucket");

                const files2 = await gbuckets.listFiles();
                console.log("Files after adding "+filename,files2);

                assert.ok(await gbuckets.fileExists(filename),"Added file does not exist");

                await gbuckets.deleteFile(filename);

                assert.ok(!await gbuckets.fileExists(filename),"removed file still exists");

                debug.log("test  ok");
            } 
            catch (error) 
            {
                throw error;               
            }

            debug.log("ALL TESTS COMPLETED WITH SUCCESS!!");                
        } 
        catch (error) 
        {
            debug.log("TEST FAILURE :  exception "+error.message||error);
            throws error;  
        }    
    }
}

module.exports = new Tests()
```

## Managing injections

Injections are other services that have been initialised and can be used in a service, a route, a test, or a node.

Injections are declared in the configuration.

example:
```yml
    # database
    firestore:
      upath: firestore@googleapi
      conPath: .firestore
      # apply_client_id = coll_prefix | coll_suffix | none | db
      apply_client_id: coll_suffix

    # i8n locale
    gdrive_locale:
      path: "@nxn/db/locale.service"
      default: en
      langs:
        en: $ref(applications/drive_indexer/locales/en_gdrive.strings)

    # db model class : manage queries to the database. Abstracts the actual db and queries.
    gdrive_model:
      path: "@nxn/db/db_model.service"
      schema: $ref(applications/drive_indexer/models/gdrive.schema)
      injections:
        db: firestore
        locale: gdrive_locale

    # File service : manage gFile objects. It interacts with storage by using above db model
    gdrive_sce:
      upath: gdrive@drive_indexer
      injections:
        model: gdrive_model        
```

**gdrive_model** service uses **firestore** and **gdrive_locale** services as injections.

And **gdrive_sce** gets **gdrive_model** as injection.

### How are injections available in services

Injections and config parameters are provided to the objects declared with their init() function.

```js
/** my service description here */
class GFileSce extends FlowNode
{
    /**
     * DB model
     * @type {DbModel} */
    model;

    constructor(instName) {
        super(instName);
    }

    /** init the service with a config */
    async init(config,ctxt,...injections) {
        super.init(config,ctxt,injections); 

        /** get DB Model */
        this.model = this.getInjection('model');
    }
    ...
}

```
the **super.init()** function gets injections and organise them in the object.
The **GFileSce** service adds the **model** injection as a member variable, by using **getInjection()**.

```js
    /** get DB Model */
    this.model = this.getInjection('model');
```

NB. injections can be **AUTOMATICALLY added as member variables** if:
1) the local variable is **declared** in the class
2) the local variable has the **same name as the injection**
3) the variable is not yet defined (its **value must be undefined**)

The above example can then be rewritten without adding a getInjection() call in the init:

```js
/** my service description here */
class GFileSce extends FlowNode
{
    /**
     * DB model (automatically loaded from injection)
     * @type {DbModel} */
    model;

    constructor(instName) {
        super(instName);
    }

    /** init the service with a config */
    async init(config,ctxt,...injections) {
        super.init(config,ctxt,injections); 
    }
    ...
}

```
